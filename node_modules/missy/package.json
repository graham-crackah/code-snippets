{
  "_args": [
    [
      {
        "name": "missy",
        "raw": "missy",
        "rawSpec": "",
        "scope": null,
        "spec": "latest",
        "type": "tag"
      },
      "/Users/graham/Documents/Code Snippets/code-snippets"
    ]
  ],
  "_from": "missy@latest",
  "_id": "missy@0.0.2",
  "_inCache": true,
  "_installable": true,
  "_location": "/missy",
  "_npmUser": {
    "email": "kolypto@gmail.com",
    "name": "kolypto"
  },
  "_npmVersion": "1.3.14",
  "_phantomChildren": {},
  "_requested": {
    "name": "missy",
    "raw": "missy",
    "rawSpec": "",
    "scope": null,
    "spec": "latest",
    "type": "tag"
  },
  "_requiredBy": [
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/missy/-/missy-0.0.2.tgz",
  "_shasum": "8720fc462f34652ef657035244653576a6e14cb8",
  "_shrinkwrap": null,
  "_spec": "missy",
  "_where": "/Users/graham/Documents/Code Snippets/code-snippets",
  "author": {
    "email": "kolypto@gmail.com",
    "name": "kolypto"
  },
  "bugs": {
    "url": "https://github.com/kolypto/nodejs-missy/issues"
  },
  "dependencies": {
    "lodash": "2.4.x",
    "q": "0.9.x"
  },
  "description": "Slim & sexy, universal ORM",
  "devDependencies": {
    "nodeunit": "0.8.x"
  },
  "directories": {},
  "dist": {
    "shasum": "8720fc462f34652ef657035244653576a6e14cb8",
    "tarball": "https://registry.npmjs.org/missy/-/missy-0.0.2.tgz"
  },
  "engines": {
    "node": ">= 0.10.0"
  },
  "homepage": "https://github.com/kolypto/nodejs-missy",
  "keywords": [
    "orm",
    "odm",
    "data-mapper",
    "postgresql",
    "mongodb"
  ],
  "license": "MIT",
  "main": "./lib/index",
  "maintainers": [
    {
      "email": "kolypto@gmail.com",
      "name": "kolypto"
    }
  ],
  "name": "missy",
  "optionalDependencies": {},
  "readme": "Missy\n=====\n\nMissy is a slim database-agnostic data mapper for NodeJS with pluggable drivers.\n\nWhenever you need a truly flexible, lightweight DB tool - she's here for you.\n\nQuick overview:\n\n* Database-agnostic. Currently, PostgreSQL and MongoDB are supported\n* Allows to customize the DB client object\n* Full CRUD operations support\n* Custom update/remove operations\n* Easy custom data types\n* Absolutely no limitations on the underlying schema and keys\n* Model events & hooks for full control\n* Rich data selection control: projections, limit/offset, sorting\n* Model relations, even across databases\n* Supports schema-less NoSQL documents with custom fields\n* MongoDB-style API\n* Reliable DB connection handling\n* Promise-based: uses the [q](https://npmjs.org/package/q) package\n* Amazingly simple and well-structured\n* Documented and rich on comments\n* 100% tests coverage\n\n\n\nTable Of Contents\n=================\n\n* <a href=\"#glossary\">Glossary</a>\n* <a href=\"#tutorial\">Tutorial</a>\n* <a href=\"#core-classes\">Core Classes</a>\n    * <a href=\"#converter\">Converter</a>\n        * <a href=\"#type-handlers\">Type Handlers</a>\n        * <a href=\"#custom-type-handlers\">Custom Type Handlers</a>\n    * <a href=\"#missyprojection\">MissyProjection</a>\n    * <a href=\"#missycriteria\">MissyCriteria</a>\n    * <a href=\"#missysort\">MissySort</a>\n    * <a href=\"#missyupdate\">MissyUpdate</a>\n* <a href=\"#driver\">Driver</a>\n    * <a href=\"#supported-drivers\">Supported Drivers</a>\n* <a href=\"#schema\">Schema</a>\n    * <a href=\"#schemadriver-settings\">Schema(driver, settings?)</a>\n    * <a href=\"#schemadefinename-fields-optionsmodel\">Schema.define(name, fields, options?):Model</a>\n    * <a href=\"#schemaregistertypename-typehandlerschema\">Schema.registerType(name, TypeHandler):Schema</a>\n    * <a href=\"#schemaconnectpromise\">Schema.connect():promise</a>\n    * <a href=\"#schemadisconnectpromise\">Schema.disconnect():promise</a>\n    * <a href=\"#schemagetclient\">Schema.getClient():*</a>\n* <a href=\"#model\">Model</a>\n    * <a href=\"#model-definition\">Model Definition</a>\n        * <a href=\"#fields-definition\">Fields Definition</a>\n        * <a href=\"#model-options\">Model Options</a>\n    * <a href=\"#helpers\">Helpers</a>\n        * <a href=\"#modelgetclientobject\">Model.getClient():Object</a>\n        * <a href=\"#modelentityimportentityq\">Model.entityImport(entity):Q</a>\n        * <a href=\"#modelentityexportentityq\">Model.entityExport(entity):Q</a>\n    * <a href=\"#operations\">Operations</a>\n        * <a href=\"#read-operations\">Read Operations</a>\n            * <a href=\"#modelgetpk-fieldsq\">Model.get(pk, fields?):Q</a>\n            * <a href=\"#modelfindonecriteria-fields-sort-optionsq\">Model.findOne(criteria?, fields?, sort?, options?):Q</a>\n            * <a href=\"#modelfindcriteria-fields-sort-optionsq\">Model.find(criteria?, fields?, sort?, options?):Q</a>\n            * <a href=\"#modelcountcriteria-optionsq\">Model.count(criteria?, options?):Q</a>\n        * <a href=\"#write-operations\">Write Operations</a>\n            * <a href=\"#modelinsertentities-optionsq\">Model.insert(entities, options?):Q</a>\n            * <a href=\"#modelupdateentities-optionsq\">Model.update(entities, options?):Q</a>\n            * <a href=\"#modelsaveentities-optionsq\">Model.save(entities, options?):Q</a>\n            * <a href=\"#modelremoveentities-optionsq\">Model.remove(entities, options?):Q</a>\n        * <a href=\"#queries\">Queries</a>\n            * <a href=\"#modelupdatequerycriteria-update-optionsq\">Model.updateQuery(criteria, update, options?):Q</a>\n            * <a href=\"#modelremovequerycriteria-optionsq\">Model.removeQuery(criteria, options?):Q</a>\n        * <a href=\"#chaining\">Chaining</a>\n            * <a href=\"#modelpickfields\">Model.pick(fields)</a>\n            * <a href=\"#modelsortsort\">Model.sort(sort)</a>\n            * <a href=\"#modelskipn\">Model.skip(n)</a>\n            * <a href=\"#modellimitn\">Model.limit(n)</a>\n        * <a href=\"#using-the-driver-directly\">Using The Driver Directly</a>\n    * <a href=\"#model-hooks\">Model Hooks</a>\n        * <a href=\"#converter-hooks\">Converter Hooks</a>\n        * <a href=\"#query-hooks\">Query Hooks</a>\n    * <a href=\"#relations\">Relations</a>\n        * <a href=\"#defining-relations\">Defining Relations</a>\n            * <a href=\"#modelhasoneprop-foreign-fields\">Model.hasOne(prop, foreign, fields)</a>\n            * <a href=\"#modelhasmanyprop-foreign-fields\">Model.hasMany(prop, foreign, fields)</a>\n        * <a href=\"#handling-related-entities\">Handling Related Entities</a>\n            * <a href=\"#modelloadrelatedentities-prop-fields-sort-optionsq\">Model.loadRelated(entities, prop, fields?, sort?, options?):Q</a>\n            * <a href=\"#modelsaverelatedentities-prop-optionsq\">Model.saveRelated(entities, prop, options?):Q</a>\n            * <a href=\"#modelremoverelatedentities-prop-optionsq\">Model.removeRelated(entities, prop, options?):Q</a>\n            * <a href=\"#modelwithrelatedprop-model\">Model.withRelated(prop, ...):Model</a>\n* <a href=\"#recipes\">Recipes</a>\n    * <a href=\"#validation\">Validation</a>\n\n\n\n\nGlossary\n========\n\nCommonly used terms:\n\n<dl>\n    <dt>Driver</dt>\n    <dd>Database driver that handles low-level Missy queries like find, insert, save, etc.</dd>\n    <dt>Schema</dt>\n    <dd>A collection of Models bound to a database Driver. Also, Type Handlers are defined on it.</dd>\n    <dt>Type Handler</dt>\n    <dd>A class that converts Field values to/from the database</dd>\n    <dt>Entity</dt>\n    <dd>An entity is a document persisted in the database</dd>\n    <dt>Model</dt>\n    <dd>A Model defines fields on some DB namespace (table, collection, etc) and provides methods to access Entities.</dd>\n    <dt>Field</dt>\n    <dd>Fields are defined on a model and specify its name and type. Other options are available</dd>\n    <dt>Relation</dt>\n    <dd>A relation is a way of accessing the associated entities</dd>\n</dl>\n\n\n\n\n\n\nTutorial\n========\n\nLet's peek at how Missy works:\n\n```js\nvar missy = require('missy'),\n    MongodbDriver = require('missy-mongodb')\n    ;\n\n// Driver\nvar mongoDriver = new MongodbDriver(function(){\n    // Connecter function\n\n}, {\n    // driver options\n    journal: true\n});\n\n// Schema\nvar schema = new missy.Schema(mongoDriver, {\n    queryWhenConnected: false // when disconnected, queries will wait for the driver to connect\n});\n\n// Models\nvar User = schema.define('User', {\n    // Fields definition\n    _id: Number, // simple form\n    name: { type: 'string', required: true }, // full form\n    ctime: { type: 'date', def: function(){ return new Date(); } }, // with a default value\n    sex: String,\n    age: Number,\n    description: String\n}, {\n    // Model options\n    pk: '_id', // Primary key\n    // table: 'users' // using the default table name: 'users'\n});\n\nvar Post = schema.define('Post', {\n    _id: Number,\n    uid: Number, // author\n    title: String,\n    body: String,\n    tags: Array\n}, {\n    pk: 'id',\n    table: 'user_posts', // the default table name would have been 'posts'. Override this.\n    entityPrototype: { // add methods to all entities\n        addTag: function(tag){\n            this.tags.push(tag);\n        }\n    }\n});\n\nvar Comment = schema.define('Comment', {\n    _id: Number,\n    post_id: Number,\n    name: String, // arbitrary user name\n    body: String\n});\n\n// Relations\nUser.hasMany('posts', Post, { 'id': 'uid' }); // name, model, fields mapping\nPost.hasOne('author', User, { 'uid': 'id' });\nComment.hasOne('post', Post, { 'post_id': '_id' });\nPost.hasMany('comments', Comment, { '_id': 'post_id' });\n\n// Model hooks\nUser.hooks.beforeExport = function(entity){ // adds a synchronous hook\n    // validate sex\n    if (['m','f'].indexOf(entity.sex) === -1)\n        entity.sex = '?';\n};\n\nUser.hooks.on('afterInsert', function(entities){ // event hook\n    // When a new user is inserted, detect teenagers\n    if (user.age < 18)\n        console.log('teens here!');\n});\n\n// Connect & action!\nschema.connect()\n    .catch(function(){ // DB error\n        console.error('DB connection failed');\n    })\n\n    // Saving entities\n    .then(function(){\n        return User\n            .withRelated('posts') // save related entities as well\n            .save([\n                { _id: 1, name: 'Lily', sex: 'f', age: 19, // `ctime` gets the default\n                  posts: [ // her posts\n                        { // no `uid` field: it automatically gets a value\n                            _id: 1, title: 'Help me', body: 'I broke my nail!', tags: ['help']\n                        }\n                    ]\n                 },\n                { _id: 2, name: 'Ivy', sex: 'f', age: 21 }, // no posts\n                { _id: 3, name: 'Carrie', sex: 'f', age: '23' } // `age` converted to Number on save\n            ]);\n    })\n\n    // Fetching entities\n    .then(function(){ // promise-based success handler callback\n        // Now the schema is connected and we can use the models\n        return User\n            .withRelated('posts') // eagerly load posts\n            .withRelated('posts.comments') // deep eager load: also load all comments\n            .find(\n                { sex: 'f', age: { $gt: 18, $lt: 25 } }, // find girls aged from 18 to 25\n                { description: 0 }, // exclude the description field from the result set\n                { age: +1 } // sort by `age` ascending\n            ); // the result is passed to the next `then()`\n    })\n\n    // Removing entities\n    .then(function(girls){\n        return User\n            .with('posts') // with posts\n            .remove(girls); // don't try this at home\n    })\n\n    // Updating an entity without loading it (!)\n    .then(function(){\n        return User.updateQuery(\n            { sex: 'f', name: 'Lily' }, // match all girls named 'Lily'\n            { $set: { description: 'Cute!' } } // set the `description` field to a compliment\n        ); // the full updated entities are returned\n    })\n\n    // Removing an entity without loading it (!)\n    .then(function(){\n        return User.removeQuery( // remove all matching entities\n            { sex: 'f', name: 'John' } // match all Johns pretending to be a girl\n        ); // the removed entities are returned\n    });\n```\n\n\n\n\n\n\nCore Classes\n============\n\nMost Missy methods use these so you'll need to know how to work with them. This includes:\n\n* Converting values to/from the database format\n* Specifying field projections\n* Search criteria format\n* Sorting entities\n* Specifying the update expressions\n\nThough most of them are designed after MongoDB, they're applicable to all DB drivers with no limitations.\n\n\n\nConverter\n---------\n\nSource: [lib/util/model.js#Converter](lib/util/model.js)\n\n`Converter` transparently transparently converts field values to/from the DB format.\n\nNOTE: `Converter` does not touch fields that are not defined in the model! Keep this in mind when working with\nNoSQL databases as in general documents can contain arbitrary fields.\n\nConsider the example:\n\n```js\nvar User = schema.define('User', {\n    id: Number,\n    name: String,\n    login: { type: 'string', required: true },\n    tags: Array,\n    ctime: { type: 'date', required: true, def: function(){ return new Date(); })\n};\n\nUser.save({ id: '1', name: 111, login: 'first', tags:'events' });\nUser.findOne({ id: '1' })\n```\n\nOn save, the 'id' field is converted to a number, name and login - to string, tags - to array.\nAlso, 'ctime' is set to the current time as no value was not provided.\n\nOn find, the query criteria 'id' field is converted to a number, and the resulting entity is converted back.\n\nIn general, `Converter` does the following:\n\n* Sets default values on fields that are `undefined` and have `def` field property set to either a value or a function.\n* Applies *type handlers* to entity fields defined in the model.\n\n### Type Handlers\n\n`Converter` is driven by *type handlers*: classes which can convert a JS value to the DB format and back.\n\nEach *type handler* has a name to be referenced in the model *fields definition*.\nAlternatively, you can use a JS built-in object as a shortcut.\n\nMissy defines some built-in type handlers in *lib/types/*:\n\n|Name         | Shortcut         | JS Type        | Default           | Comment                                                       |\n|-------------|------------------|----------------|-------------------|---------------------------------------------------------------|\n| any         | undefined        | *              | undefined         | No-op converter to use the value as is                        |\n| string      | String           | `String,null`  | `'', null`        | Ensure a string, or `null`                                    |\n| number      | Number           | `Number,null`  | `0, null`         | Ensure a number, or `null`                                    |\n| boolean     | Boolean          | `Boolean,null` | `false, null`     | Ensure a boolean, or `null`                                   |\n| date        | Date             | `Date,null`    | `null`            | Convert to JS `Date`, or `null`                               |\n| object      | Object           | `Object,null`  | `{}, null`        | Use a JS `Object`, or `null`.                                 |\n| array       | Array            | `Array,null`   | `[], null`        | Ensure an array, or `null`. Creates arrays from scalar values |\n| json        | -                | `String,null`  | `null`            | Un/serializes JSON, or `null`. Throws `MissyTypeError` on parse error.  |\n\nNote: most built-in types allow `null` value only when the field is not defined as `required` (see below).\n\nNote: DB drivers may define own type handlers and even redefine standard types for all models handled by the driver.\n\nAlso, the following aliases are defined:\n\n| Alias                                     | Definition                        |\n|-------------------------------------------|-----------------------------------|\n| bool                                      | `{ type: 'boolean' }`             |\n| int                                       | `{ type: 'number' }`              |\n| float                                     | `{ type: 'number' }`              |\n\n### Custom Type Handlers\n\nA *type handler* is a class that implements the `IMissyTypeHandler` interface (*lib/interfaces.js*):\n\n* Constructor receives 2 arguments: the schema to bind to, and the type handler name.\n* Method `load(value, field)` which converts a value loaded from the database\n* Method `save(value, field)` which converts a value to be stored to the database\n* Method `norm(value, field)` which normalizes the value\n* Has 2 properties: `schema` and `name`\n\nOnce the type handler is defined, you register in on a `Schema`:\n\n```js\nvar stringTypeHandler = require('missy').types.String;\nschema.registerType('string', stringTypeHandler);\n\n// Now you can use it on a model:\nvar User = schema.define('User', {\n    login: { type: 'string' }\n});\n```\n\nNote: built-in types are registered automatically, there's no need to follow this example.\n\n\n\nMissyProjection\n---------------\n\nSource: [lib/util/model.js#MissyProjection](lib/util/model.js)\n\nWhen selecting entities from the DB, you may want to fetch a subset of fields. This is what `MissyProjection` does:\nallows you to specify the fields to include or exclude from the resulting entities.\n\n`MissyProjection` closely follows\n[MongoDB Projections](http://docs.mongodb.org/manual/core/read-operations/#projections) specification.\n\nA projection can be used in one of the 3 available modes:\n\n* *all mode*. All available fields are fetched.\n* *inclusion mode*. Fetch the named fields only.\n* *exclusion mode*. Fetch all fields except the named ones.\n\nThe following projection input formats are supported:\n\n* **String syntax**. Projection mode + Comma-separated field names.\n\n    * `'*'`: include all fields\n    * `'+a,b,c'`: include only fields *a, b, c*\n    * `'-a,b,c'`: exclude fields *a, b, c*\n\n* **Array syntax**. Array of field names to include.\n\n    * `[]`: include all fields\n    * `['a','b','c']`: include only fields *a, b, c*\n    * Exclusion mode is not supported\n\n* **Object syntax**. MongoDB-style projection object.\n\n    * `{}`: include all fields\n    * `{ a:1, b:1, c:1 }`: include only fields *a, b, c*\n    * `{ a:0, b:0, c:0 }`: exclude fields *a, b, c*\n\n* **MissyCriteria**. A `MissyCriteria` object.\n\nUsage example:\n\n```js\nvar User = schema.define('User', {\n    id: Number,\n    login: String,\n    //...\n});\n\nUser.find({}, { id:1, login: 1 }) // only fetch 2 fields: id, login\n    .then(function(users){ ... });\n```\n\n\n\nMissyCriteria\n-------------\n\nSource: [lib/util/model.js#MissyCriteria](lib/util/model.js)\n\nSpecifies the search conditions.\n\nImplements a simplified version of\n[MongoDB `collection.find` criteria document](http://docs.mongodb.org/manual/reference/method/db.collection.find/):\n\n* Use `{ field: value, .. }` syntax to match entities by equality ;\n* Use `{field: { $operator: value, .. }, .. }` syntax to compare with an operator.\n\nExample:\n\n```js\n{\n    id: 1, // equality\n    login: { $eq: 'kolypto' }, // equality with an operator\n    role: { $in: ['admin','user'] }, // $in operator example\n    age: { $gt: 18, $lt: 22 } // 2 operators on a single field\n}\n```\n\nNote: To keep the implementation simple and effective, Missy does not support complex queries and logical operators.\n    If you need them, see [Using The Driver Directly](#using-the-driver-directly).\n\nThe following operators are supported:\n\n| Operator | Definition | Example                                 | Comment                                   |\n|----------|------------|-----------------------------------------|-------------------------------------------|\n| `$gt`    | >          | `{ money: { $gt: 20000 } }`             | Greater than                              |\n| `$gte`   | <=         | `{ height: { $gte: 180 } }`             | Greater than or equal                     |\n| `$eq`    | ==         | `{ login: { $eq: 'kolypto' } }`         | Equal to                                  |\n| `$ne`    | !=         | `{ name: { $ne: 'Lucy' } }`             | Not equal to                              |\n| `$lt`    | <          | `{ age: { $lt: 18 } }`                  | Lower than                                |\n| `$lte`   | <=         | `{ weight: { $lte: 50 } }`              | Lower than or equal                       |\n| `$in`    | IN         | `{ role: { $in: ['adm', 'usr' ] } }`    | In array of values. Scalar operand is converted to array. |\n| `$nin`   | NOT IN     | `{ state: { $nin: ['init','error'] } }` | Not in array of values. Scalar operand is converted to array. |\n\nBefore querying, `MissyCriteria` uses `Converter` to convert the given field values to the DB types.\nFor instance, the `{ id: '1' }` criteria will be converted to `{ id: { $eq: 1 } }`.\n\nExample:\n\n```js\nvar User = schema.define('User', {\n    age: Number,\n    //...\n});\n\nUser.find({ age: { $gt: 18, $lt: 22 } }) // 18 <= age <= 22\n    .then(function(users){ ... });\n```\n\n\n\nMissySort\n---------\n\nSource: [lib/util/model.js#MissySort](lib/util/model.js)\n\nDefines the sort order of the result set.\n\n`MissySort` closely follows the\n[MongoDB sort](http://docs.mongodb.org/manual/reference/method/cursor.sort/#cursor-sort) specification.\n\nThe following sort input formats are supported:\n\n* **String syntax**. Comma-separated list of fields suffixed by the sorting operator: `+` or `-`.\n\n    * `a,b+.c-`: sort by *a* asc, *b* asc, *c* desc\n\n* **Array syntax**. Same as *String syntax*, but split into an array.\n\n    * `['a', 'b+', 'c-' ]`: sort by *a* asc, *b* asc, *c* desc\n\n* **Object syntax**. MongoDB-style object which maps field names to sorting operator: `1` or `-1`.\n\n    * `{ a: 1, b: 1, c: -1 }`: sort by *a* asc, *b* asc, *c* desc\n\nExample:\n\n```js\nvar User = schema.define('User', {\n    id: Number,\n    age: Number,\n    //...\n});\n\nUser.find({}, {}, { age: -1 }) // sort by `age` descending\n    .then(function(users){ ... });\n```\n\n\n\nMissyUpdate\n-----------\n\nSource: [lib/util/model.js#MissyUpdate](lib/util/model.js)\n\nDeclares the update operations to perform on matching entities.\n\n`MissyUpdate` implements the simplified form of\n[MongoDB update document](http://docs.mongodb.org/manual/reference/method/db.collection.update/#update-parameter).\n\n* Use `{ field: value, .. }` syntax to set a field's value ;\n* Use `{ $operator: { field: value } }` syntax to apply a more complex action defined by the operator.\n\nExample:\n\n```js\n{\n    mtime: new Date(),                      // assign a value\n    $set: { mtime: new Date() },            // assign a value\n    $inc: { hits: +1 },                     // increment a field\n    $unset: { error: '' },                  // unset a field\n    $setOnInsert: { ctime: new Date() },    // set on insert, not update\n    $rename: { 'current': 'previous' }      // rename a field\n}\n```\n\nThe following operators are supported:\n\n| Operator          | Comment                                                                                          |\n|-------------------|--------------------------------------------------------------------------------------------------|\n| `$set`            | Set the value of a field                                                                         |\n| `$inc`            | Increment the value of a field by the specified amount. To decrement, use negative amounts       |\n| `$unset`          | Remove the field (with some drivers: set it to `null`)                                           |\n| `$setOnInsert`    | Set the value of a field only when a new entity is inserted (see `upsert` with [Model.updateQuery](#modelupdatequerycriteria-update-optionsq))      |\n| `$rename`         | Rename a field                                                                                   |\n\nBefore querying, `MissyUpdate` uses `Converter` to convert the given field values to the DB types.\nFor instance, the `{ id: '1' }` criteria will be converted to `{ $set: { id: 1 } }`.\n\nExample:\n\n```js\nvar User = schema.define('User', {\n    id: Number,\n    mtime: Date,\n    //...\n});\nUser.updateQuery({ id: 1 }, { $set: { mtime: new Date(); } }) // update mtime without fetching\n    .then(function(user){ ... });\n```\n\n\n\n\n\n\nDriver\n======\n\nMissy is a database abstraction and has no DB-specific logic, while *Drivers* implement the missing part.\nA Driver is a class that implements the `IMissyDriver` interface (*lib/interfaces.js*).\n\nEach driver is created with a *connecter* function: a function that returns a database client through a promise.\nMissy does not handle it internally so you can specify all the necessary options and tune the client to your taste.\n\nThe first thing you start with is instantiating a driver.\n\n```js\nvar missy = require('missy');\n\n// For demo, we'll use `MemoryDriver`: it does not require any connecter function at all.\nvar memory = new missy.drivers.MemoryDriver();\n```\n\nNote: `MemoryDriver` is built into Missy, but is extremely slow: it's designed for unit-tests and not for production!\n\nAt the user level, you don't use the driver directly. However, it has two handy events:\n\n```js\nmemory.on('connect', function(){\n    console.log('Driver connected');\n});\n\nmemory.on('disconnect', function(){\n    console.log('Driver disconnected');\n});\n```\n\nEach driver has (at least) the following properties:\n\n* `client:*`: The DB client\n* `connected:Boolean`: Whether the client is currently connected\n\n## Supported Drivers\n\nMissy drivers are pluggable: just require another package, and you'll get a new entry under `missy.drivers`.\n\n| Driver            | Database          | Package name                                                | Github                                            |\n|-------------------|-------------------|-------------------------------------------------------------|---------------------------------------------------|\n| `MemoryDriver`    | in-memory         | [missy](https://npmjs.org/package/missy)                    | built-in                                          |\n| `PostgresDriver`  | PostgreSQL        | [missy-postgres](https://npmjs.org/package/missy-postgres)  | <https://github.com/kolypto/nodejs-missy-postgres>|\n| `MongodbDriver`   | MongoDB           | [missy-mongodb](https://npmjs.org/package/missy-mongodb)    | <https://github.com/kolypto/nodejs-missy-mongodb> |\n\nContributions are welcome, provided your driver is covered with unit-tests :)\n\n\n\n\n\n\nSchema\n======\n\nSource: [lib/Schema.js#Schema](lib/Schema.js)\n\nThe instantiated driver is useless on its own: you just pass it to the `Schema` object which is the bridge that connects\nyour *Models* with the Driver of your choice.\n\nYou're free to use multiple schemas with different drivers: Missy is smart enough to handle them all, *with no limitations*.\n\nNote: a single driver can only be used with a single schema!\n\n```js\nvar missy = require('missy');\n\n// Create: Driver, Schema\nvar driver = new missy.drivers.MemoryDriver(),\n    schema = new missy.Schema(driver, {});\n\n// Initially, the schema is not connected\n\nschema.connect()\n    .then(function(){\n        console.log('DB connected!');\n    });\n```\n\n\n## Schema(driver, settings?)\n\nConstructor. Creates a schema bound to a driver.\n\n* `driver:IMissyDriver`: The driver to work with\n* `settings:Object?`: Schema settings. An object:\n\n    * `queryWhenConnected: Boolean`\n\n        Determines how to handle queries on models of a disconnected schema.\n\n        When `false` (default), querying on a disconnected schema throws `MissyDriverError`\n\n        When `true`, the query is delayed until the driver connects.\n\n    Source: [lib/options.js#SchemaSettings](lib/options.js)\n\nInitially, the schema is not connected. Use `Schema.connect()` to make the driver connect.\n\nA `Schema` instance has the following properties:\n\n* `driver:IMissyDriver`: The driver the schema is bound to\n* `settings:Object`: Schema settings object\n* `types:Object.<String, IMissyTypeHandler>`: Custom type handlers defined on the schema\n* `models:Object.<String, Model>`: Models defined on the schema\n\n## Schema.define(name, fields, options?):Model\n\nDefines a model on the schema. The model uses the driver bound to the schema.\n\nNote: you can freely define models on a schema that is not connected.\n\n* `name:String`: Model name\n* `fields:Object`: Model fields definition\n* `options:Object?`: Model options\n\nSee: [Model Definition](#model-definition).\n\n```js\nschema.define('User', {\n    id: Number,\n    login: String\n}, { pk: 'id' });\n```\n\n## Schema.registerType(name, TypeHandler):Schema\n\nRegister a custom [Type Handler](#type-handlers) on this schema. This type becomes available to all models\ndefined on the schema.\n\n* `name: String`: The type handler name. Use it in model fields: `{ type: 'name' }`.\n* `TypeHandler:IMissyTypeHandler`: The type handler class to use. Must implement `IMissyTypeHandler`\n\nSee: [Custom Type Handlers](#custom-type-handlers)\n\n## Schema.connect():promise\n\nAsk the driver to connect to the database.\n\nReturns a promise.\n\n```js\nschema.connect()\n    .then(function(){\n        // DB connected\n    })\n    .catch(function(err){\n        // DB connection error\n    });\n```\n\nNote: once connected, the Schema automatically reconnects when the connection is lost.\n\n## Schema.disconnect():promise\n\nAsk the driver to disconnect from the database.\n\nReturns: a promise\n\n```js\nschema.disconnect()\n    .then(function(){\n        // Disconnected\n    });\n```\n\nNote: this disables automatic reconnects until you explicitly `connect()`.\n\n## Schema.getClient():*\n\nConvenience method to get the vanilla DB client of the underlying driver.\n\nHandy when you need to make some complex query which is not supported by Missy.\n\nSee: [Using The Driver Directly](#using-the-driver-directly)\n\n\n\n\n\n\nModel\n=====\n\nSource: [lib/Model.js#Model](lib/Model.js)\n\nA *Model* is the representation of some database namespace: a table, a collection, whatever.\nIt defines the rules for a certain type of entity, including its fields and business-logic.\n\nOnce defined, a model has the following properties:\n\n* `schema:Schema`: The Schema the Model is defined on\n* `name:String`: Model name\n* `fields:Object.<String, IModelFieldDefinition>`: Field definitions\n* `options:Object`: Model options\n* `relations:Object.<String, IMissyRelation>`: Relation handlers\n\n\n\nModel Definition\n----------------\nTo define a `Model` on a `Schema`, you use [`schema.define()`](#schemadefinename-fields-optionsmodel):\n\n```js\nvar missy = require('missy');\n\nvar driver = new missy.drivers.MemoryDriver(),\n    schema = new missy.Schema(driver, {});\n\nvar User = schema.define('User', {\n    id: Number,\n    login: { type: String, required: true }\n}, { pk: 'id' });\n```\n\n`Schema.define` accepts the following arguments:\n\n* `name:String`: Model name.\n* `fields:Object`: Model fields definition\n* `options:Object?`: Model options\n\n### Fields Definition\n\nSource: [lib/interfaces.js#IModelFieldDefinition](lib/interfaces.js)\n\nAs stated in the [type handlers](#type-handlers) section, a field definition can be:\n\n* A native JavaScript type (`String`, `Number`, `Date`, `Object`, `Array`)\n* A Field *type handler* string name: `'string'`, `'any'`, etc.\n* An object with the following fields:\n\n    * `type:String`: Field type handler\n    * `required:Boolean?`: Is the field required?\n\n        A required field is handled differently by *type handlers*: it is now allowed to contain `null` and gets some\n        default value determined by the *type handler*.\n\n        Default value: uses `required` from [model options](#model-options).\n\n    * `def:*|function(this:Model)`: The default value to use when the field is `undefined`.\n\n        Can be either a value, or a function that returns a value.\n\n        The default value is used when an entity is being saved to the DB, and the field value is either `undefined`,\n        or `null` and having the `required=true` attribute.\n\n### Model Options\n\nSource: [lib/options.js#ModelOptions](lib/options.js)\n\n* `table:String?`: the database table name to use.\n\n    Default value: Missy casts the model name to lowercase and adds 's'.\n    For instance, 'User' model will get the default table name of 'users'.\n\n* `pk:String|Array.<String>?`: the primary key field name, or an array of fields for compound PK.\n\n    Every model in Missy needs to have a primary key.\n\n    Default value: `'id'`\n\n* `required:Boolean?`: The default value for fields' `required` attribute.\n\n    Default value: `false`\n\n* `entityPrototype: Object?`: The prototype of all entities fetched from the database.\n\n    This is the Missy way of adding custom methods to individual entities:\n\n    ```js\n    var Wallet = schema.define('Wallet', {\n        uid: Number,\n        amount: Number,\n        currency: String\n    }, {\n        pk: 'uid',\n        entityPrototype: {\n            toString: function(){\n                return this.amount + ' ' + this.currency;\n            }\n        }\n    });\n\n    Wallet.findOne(1) // assuming there exists { uid: 1, amount: 100, currency: 'USD' }\n        .then(function(wallet){\n            console.log(wallet + ''); // -> 100 USD\n        });\n    ```\n\n\n\nHelpers\n-------\n\nThe following low-level model methods are available in case you need to manually handle\nentities that were fetched or are going to be stored by [using the driver directly](#using-the-driver-directly):\n\n### Model.getClient():Object\nReturns the vanilla DB client from the Schema.\n\n### Model.entityImport(entity):Q\nProcess an entity (or an array of them) loaded from the DB, just like Missy does it:\n\n* Invoke model hooks (see: [Model Hooks](#model-hooks))\n* Use `Converter` to apply field types\n* Assign entity prototypes (if configured)\n\nReturns a promise for an entity (or an array of them).\n\n```js\nvar Post = schema.define('Post', {\n    id: Number,\n    title: String,\n    tags: Array\n});\n\nPost.entityImport({ id: '1', title: 1111, tags: 'test' })\n    .then(function(entity){\n        console.log(entity); // { id: 1, title: '1111', tags: ['test'] }\n    });\n```\n\n### Model.entityExport(entity):Q\n\nProcess an entity (or an array of them) before saving it to the DB, just like Missy does it:\n\n* Invoke model hooks (see: [Model Hooks](#model-hooks))\n* Use `Converter` to apply field types\n\nReturns a promise for an entity (or an array of them).\n\n\n\nOperations\n----------\n\nAll examples use the following schema:\n\n```js\nvar User = schema.define('User', {\n    id: Number,\n    name: String,\n    age: Number,\n    sex: String\n});\n```\n\nAll promise-returning methods can return the following error:\n\n* `MissyDriverError`: driver-specific error\n\n\n\n### Read Operations\n\n#### Model.get(pk, fields?):Q\n\nGet a single entity by its primary key.\n\nArguments:\n\n* `pk: *|Array|Object`: The Primary Key value. For compound primary keys, use array or object of values.\n\n    Accepts the following values:\n\n    * `pk: *`: Any scalar primary key value. Only applicable for single-column Primary Keys.\n    * `pk: Array`: An array of PK values. Use with compound Primary Keys.\n    * `pk: Object`: PK values as an object.\n\n* `fields: String|Array|Object|MissyProjection?`: [Fields projection](#missyprojection).\n\nReturns: a promise for an entity, or `null` when the entity is not found.\n\nErrors:\n\n* `MissyModelError`: invalid primary key: empty or incomplete.\n\n```js\n// single-column PK\nvar User = schema.define('User', {id: Number }, { pk: 'id' });\n\nUser.get(1) // get User(id=1)\n    .then(function(entity){ /*...*/ });\n\nUser.get([1], ['id', 'login']) // User(id=1) ; only fetch fields `id`, `login`\n    .then(function(entity){ /*...*/ });\n\nUser.get({ id: 1 }, { id: 1, login: 1 }) // User(id=1) ; only fetch fields `id`, `login`\n    .then(function(entity){ /*...*/ });\n\n// multi-column PK\nvar Post = schema.define('Post', { uid: Number, id: Number }, { pk: ['uid','id'] });\n\nUser.get([1, 15]) // get Post(uid=1,id=15)\n    .then(function(entity){ /* ... */ });\n\nUser.get({ uid: 1, id: 15 }, { roles: 0 }) // get Post(uid=1,id=15) ; omit field `roles`\n    .then(function(entity){ /* ... */ });\n\nUser.get({ uid: 1 }) // incomplete PK\n    .catch(function(e){ /* e=MissyModelError: incomplete PK */ });\n```\n\n\n\n#### Model.findOne(criteria?, fields?, sort?, options?):Q\n\nFind a single entity matching the specified criteria.\nWhen multiple entities are found - only the first one is returned.\n\nArguments:\n\n* `criteria: Object|MissyCriteria?`: [Search criteria](#missycriteria)\n* `fields: String|Object|MissyProjection?`: [Fields projection](#missyprojection)\n* `sort: String|Object|Array|MissySort?`: [Sort specification](#missysort)\n* `options: Object?`: Driver-specific options, if supported.\n\nReturns: a promise for an entity, or `null` when no entity is found.\n\n```js\nUser.findOne(\n    { age: { $gt: 18, $lt: 21 }, sex: 'f' }, // criteria\n    { id: 1, name: 1 }, // projection\n    { age: -1 } // sort\n).then(function(user){\n    //...\n});\n```\n\n\n#### Model.find(criteria?, fields?, sort?, options?):Q\n\nFind all entities matching the specified criteria.\n\nArguments:\n\n* `criteria: Object|MissyCriteria?`: [Search criteria](#missycriteria)\n* `fields: String|Object|MissyProjection?`: [Fields projection](#missyprojection)\n* `sort: String|Object|Array|MissySort?`: [Sort specification](#missysort)\n* `options: Object?`: Driver-specific options, if supported.\n\n    Options supported by all drivers:\n\n    * `skip: Number?`: The number of entities to skip. Default: `0`, no skip\n    * `limit: Number?`: Limit the returned number of entities. Default: `0`, no limit\n\nReturns: a promise for an array or entities.\n\n```js\nUser.find(\n    { age: { $gt: 18, $lt: 21 }, sex: 'f' }, // criteria\n    { id: 1, name: 1 }, // projection\n    { age: -1 }, // sort\n    { skip: 0, limit: 10 } // 10 per page, first page\n).then(function(users){\n    //...\n});\n```\n\n#### Model.count(criteria?, options?):Q\n\nCount entities that match the criteria\n\nArguments:\n\n* `criteria: Object|MissyCriteria?`: [Search criteria](#missycriteria)\n* `options: Object?`: Driver-specific options, if supported.\n\nReturns: a promise for a number.\n\n```js\nUser.count({ sex: 'f' })\n    .then(function(girlsCount){ /* ... */ });.\n});\n```\n\n### Write Operations\n\n#### Model.insert(entities, options?):Q\n\nInsert a new entity (or an array of them).\n\nArguments:\n\n* `entities: Object|Array.<Object>`: a single entity, or an array of them.\n* `options: Object?`: Driver-specific options, if supported.\n\nReturns: a promise for the inserted entity (or an array of them).\n\nErrors:\n\n* `EntityExists`: the entity already exists\n\nNotes:\n\n* The drivers are required to return entities as saved by the DB, and in the order matching the input.\n* If any entity already exists, the driver throws an exception and stops.\n  Entities that were already inserted are not removed.\n\n```js\n// Insert a single entity\nUser.insert({ login: 'Carrie', age: 23})\n    .then(function(entity){\n        entity.id; // was set by the DB\n    })\n    .catch(function(err){\n        if (err instanceof missy.errors.EntityExists){\n            // ...\n        } else throw err; // throw it to the upper chain\n    }).done()\n    ;\n\n// Insert an array of entities\nUser.insert([\n    { login: 'Carrie', age: 23},\n    { login: 'Lily', age: 19},\n\n]).then(function(entities){ /* ... */ });\n```\n\n#### Model.update(entities, options?):Q\n\nUpdate (replace) an existing entity (or an array of them).\n\nArguments:\n\n* `entities: Object|Array.<Object>`: a single entity, or an array of them.\n* `options: Object?`: Driver-specific options, if supported.\n\nReturns: a promise for the updated entity (or an array of them).\n\nErrors:\n\n* `EntityNotFound`: the entity does not exist\n\n```js\n// Insert a single entity\nUser.update({ _id: 1, login: 'Carrie', age: 23})\n    .then(function(entity){ /* ... */ });\n```\n\n#### Model.save(entities, options?):Q\n\nSave an arbitrary entity (or an array of them).\nThis inserts the missing entities and updates the existing ones.\n\nArguments:\n\n* `entities: Object|Array.<Object>`: a single entity, or an array of them.\n* `options: Object?`: Driver-specific options, if supported.\n\nReturns: a promise for the entity (or an array of them).\n\n```js\nUser.save({ login: 'Carrie', age: 23})\n    .then(function(entity){\n        entity.id; // was set by the DB\n    })\n```\n\n#### Model.remove(entities, options?):Q\n\nRemove an existing entity (or an array of them) from the database.\n\nArguments:\n\n* `entities: Object|Array.<Object>`: a single entity, or an array of them.\n* `options: Object?`: Driver-specific options, if supported.\n\nReturns: a promise for the entity (or an array of them).\n\nErrors:\n\n* `EntityNotFound`: the entity does not exist\n\n```js\nUser.remove({ _id: 1 }) // PK is enough\n    .then(function(entity){\n        entity; // the full removed entity\n    });\n```\n\n### Queries\n\n#### Model.updateQuery(criteria, update, options?):Q\n\nUpdate entities that match a criteria using update operators.\nThis tool allows to update entities without actually fetching them.\nDB drivers do this atomically, if possible.\n\nArguments:\n\n* `criteria: Object|MissyCriteria`: [Search criteria](#missycriteria)\n* `update: Object|MissyUpdate`: [Update operations](#missyupdate)\n* `options: Object?`: Driver-specific options, if supported.\n\n    Options supported by all drivers:\n\n    * `upsert: Boolean?`: Do an *upsert*: when no entity matches the criteria, a new entity is built from the criteria\n      (equality operators converted to values) and update operators applied to it. Default: `false`\n    * `multi: Boolean?`: Allow updating multiple entities. In `multi=true` mode, the method returns an array.\n      Default: `false`\n\nReturns: a promise for a full updated entity or `null` when no matching entity is found.\nWhen `multi=true`, returns an array of entities.\n\n```js\n// update a single entity\nUser.updateQuery({ name: 'Ivy' }, { $inc: { age: 1 } ) // find 'Ivy' and add a year\n    .then(function(user){ // 1 user\n        user; // the full entity, or `null` when none found\n    });\n\n// update multiple entities\nUser.updateQuery({ age: { $lt: 18 } }, { banned: true }, { multi: true } ) // find teens and ban them\n    .then(function(users){ // multiple users\n        users; // array of matching users. Empty array when none found\n    });\n\n// upsert an entity\nUsers.updateQuery({ name: 'Dolly' }, { age: 22 }, { upsert: true })\n    .then(function(user){ // 1 user\n        user; // { id: 1, name: 'Dolly', age: 22 } - either updated or inserted\n    });\n```\n\n#### Model.removeQuery(criteria, options?):Q\n\nRemove entities that match a criteria.\nThis tool allows to remove entities without actually fetching them.\nDB drivers do this atomically, if possible.\n\nArguments:\n\n* `criteria: Object|MissyCriteria`: [Search criteria](#missycriteria)\n* `options: Object?`: Driver-specific options, if supported.\n\n    Options supported by all drivers:\n\n    * `multi: Boolean?`: Allow removing multiple entities. In `multi=true` mode, the method returns an array.\n      Default: `true`\n\nReturns: a promise for a removed entity or `null` when no matching entity is found.\nWhen `multi=true`, returns an array of entities.\n\n```js\n// remove a single entity\nUser.removeQuery({ id: 1 }, { multi: false })\n    .then(function(user){\n        user; // the removed user or `null` when none found\n    });\n\n// remove multiple entities\nUser.removeQuery({ age: { $lt: 18 } }) // remove teens\n    .then(function(users){ // multiple users\n        users; // array of removed users. Empty array when none found\n    });\n```\n\n### Chaining\n\nSome Missy methods support chaining: the specified arguments are stashed for the future and used by the target method.\n\nCurrently, the following methods are supported: `Model.get()`, `Model.findOne()`, `Model.find()`.\n\n\n\n#### Model.pick(fields)\nStash the `fields` argument for the next query.\n\n```js\nUser.pick({ id: 1, name: 1}).find();\n```\n\n#### Model.sort(sort)\nStash the `sort` argument for the next query.\n\n```js\nUser.sort({ id: -1 }).find();\n```\n\n#### Model.skip(n)\nStash the `skip` option for the next query.\n\n```js\nUser.skip(10).find();\n```\n\n#### Model.limit(n)\nStash the `limit` option for the next query.\n\n```js\nUser.limit(10).find();\n```\n\n\n\n### Using The Driver Directly\n\nMissy [search criteria](#missycriteria) is limited in order to keep the implementation simple.\nTo make complex queries, you'll need to use the Driver directly, and optionally pass the returned entities through Missy.\n\nIn order to mimic Missy behavior, you need to do the following:\n\n1. Get the vanilla DB client object from the Schema or Model.\n2. Execute a query using the client\n3. Use Missy methods to preprocess the data. This includes the hooks!\n\nMongoDB Example:\n\n```js\nvar Q = require('q');\n\nvar client = User.getClient(); // get the vanilla DB client\n\n// Load an entity\nQ.nmcall(\n    client.collection(User.options.table),\n    'findOne', // method, wrapped in a promise\n    {\n        $or: [\n            // find any root user\n            { role: 'root' },\n            { id: 0 }\n        ]\n    }\n    ).then(function(entity){\n        return User.entityImport(entity); // process the loaded value with Missy\n    })\n    .then(function(entity){\n        entity; // converted from DB format!\n    });\n\n// Save an entity\nvar entity = { id: '0', age: '23' }; // wrong field types!\n\nUser.entityExport(entity)\n    .then(function(entity){\n        entity; // { id: 0, age: 23 } - converted!\n        return Q.nmcall(\n            client.collection(User.options.table),\n            'save',\n            entity\n        );\n    });\n```\n\n\n\n\n\n\nModel Hooks\n-----------\n\nMissy Models allow you to hook into the internal processes, which allow you to preprocess the data, tune the\ninternal behavior, or just tap the data.\n\nHooks are implemented with [`MissyHooks`](lib/util/hooks.js) which is instantiated under the `Model.hooks` property of\nevery mode. It supports both synchronous hooks and event hooks.\n\nYou can assign synchronous hooks which are executed within the Missy and can interfere with the process:\n\n```js\n// Add a hook\nUser.hooks.beforeInsert = function(entities, ctx){\n    _.each(entities, function(entity){\n        entity.ctime = new Date(); // set the creation date\n    });\n};\n```\n\nAlso, you can subscribe to events named after the available hooks:\n\n```js\nUser.hooks.on('afterInsert', function(entities, ctx){\n    _.each(entities, function(entity){\n        console.log('New user created: ', entity);\n    });\n});\n```\n\nAlmost every Missy method is integrated with the hook system.\n\n### Converter Hooks\nAllow you to hook into `entityImport()` and `entityExport()` functions and alter the way entities are preprocessed\nwhile Missy talks to database driver.\n\n| Hook name         | Arguments                | Called in                                                             | Usage example               |\n|-------------------|--------------------------|-----------------------------------------------------------------------|-----------------------------|\n| `beforeImport`    | `entity:Object`          | In `entityImport()` right after fetching the entity from the DB. | Prepare values fetched from the DB |\n| `afterImport`     | `entity:Object`          | In `entityImport()` after the field type convertions are applied to the entity. | Final tuning before the entity is returned to the user |\n| `beforeExport`    | `entity:Object`          | In `entityExport()` right after the entity is provided by the Missy user | Sanitize the data |\n| `afterExport`     | `entity:Object`          | In `entityExport()` after the field type convertions are applied to the entity. | Prepare the data before storing it to the DB ; Validation |\n\n```js\nUser.afterExport = function(entity){\n    delete entity.password; // never expose the password\n};\n```\n\n### Query Hooks\nAllow you to hook into Missy query methods and alter the way these are executed, including all the input/output values.\n\nAll hooks receive the [`ctx: IModelContext`](lib/interfaces.js) argument: an object that holds the current query context.\nIn hooks, you can modify its fields to alter the Missy behavior. `ctx` fields set depends on the query, but in general:\n\n* `ctx.model: Model`: The model the query is executed on\n* `ctx.criteria: MissyCriteria?`: Search criteria\n* `ctx.fields: MissyProjection?`: Fields projection\n* `ctx.sort: MissySort?`: Sorting\n* `ctx.update: MissyUpdate?`: Update operations\n* `ctx.options: Object?`: Driver-dependent options\n* `ctx.entities: Array.<Object>?`: The entities being handled (fetched or returned)\n\nEach missy method invokes its own pair of `before*` and `after*` hooks.\nThe `after*` hook is not invoked when an error occurs.\n\nIn addition, methods that accept/return entities invoke `entityImport()` and `entityExport()` on every entity,\nwhich in turn triggers the [converter hooks](#converter-hooks) described above.\n\n| Hook name           | Arguments                                       | Model method      |\n|---------------------|-------------------------------------------------|-------------------|\n| `beforeFindOne`     | `entity:undefined, ctx: IModelContext`          | `findOne()`       |\n| `afterFindOne`      | `entity:Object, ctx: IModelContext`             | `findOne()`       |\n| `beforeFind`        | `entities:undefined, ctx: IModelContext`        | `find()`          |\n| `afterFind`         | `entities:Array.<Object>, ctx: IModelContext`   | `find()`          |\n| `beforeInsert`      | `entities:Array.<Object>, ctx: IModelContext`   | `insert()`        |\n| `afterInsert`       | `entities:Array.<Object>, ctx: IModelContext`   | `insert()`        |\n| `beforeUpdate`      | `entities:Array.<Object>, ctx: IModelContext`   | `update()`        |\n| `afterUpdate`       | `entities:Array.<Object>, ctx: IModelContext`   | `update()`        |\n| `beforeSave`        | `entities:Array.<Object>, ctx: IModelContext`   | `save()`          |\n| `afterSave`         | `entities:Array.<Object>, ctx: IModelContext`   | `save()`          |\n| `beforeRemove`      | `entities:Array.<Object>, ctx: IModelContext`   | `remove()`        |\n| `afterRemove`       | `entities:Array.<Object>, ctx: IModelContext`   | `remove()`        |\n| `beforeUpdateQuery` | `entities:undefined, ctx: IModelContext`        | `updateQuery()`   |\n| `afterUpdateQuery`  | `entities:Array.<Object>, ctx: IModelContext`   | `updateQuery()`   |\n| `beforeRemoveQuery` | `entities:undefined, ctx: IModelContext`        | `removeQuery()`   |\n| `afterRemoveQuery`  | `entities:Array.<Object>, ctx: IModelContext`   | `removeQuery()`   |\n\n\n\n\n\n\nRelations\n---------\n\nMissy supports automatic loading & saving of related entities assigned to the host entities.\n\n### Defining Relations\n\n#### Model.hasOne(prop, foreign, fields)\nDefine a *1-1* or *N-1* relation to a foreign Model `foreign`, stored in the local field `prop`.\n\nArguments:\n\n* `prop: String`: Name of the local property to handle the related entity in. This also becomes the name of the relation.\n* `foreign: Model`: The foreign Model\n* `fields: String|Array.<String>|Object`: Name of the common Primary Key field, or an array of common fields, or an object with the fields' mapping:\n\n    ```js\n   Article.hasOne('author', User, 'user_id');\n   Article.hasOne('author', User, { 'user_id': 'id' });\n    ```\n\nAfter a relation was defined, the local model's `prop` field will be used for loading & saving the related entity.\n\n#### Model.hasMany(prop, foreign, fields)\nDefine a *1-N* relation to a foreign Model.\n\nSame as `hasOne`, but handles an array of related entities.\n\n\n\n### Handling Related Entities\n\n#### Model.loadRelated(entities, prop, fields?, sort?, options?):Q\nFor the given entities, load their related entities as defined by the `prop` relation.\n\nArguments:\n\n* `entities: Object|Array.<Object>`: Entity of the current model, or an array of them\n* `prop: String|Array.<String>|undefined`: The relation name to load, or multiple relation names as an array.\n\n    When `undefined` is given, all available relations are loaded.\n\n    You can also load nested relations using the '.'-notation: `'articles.comments'` (see [Model.withRelated](#modelwithrelatedprop-model)).\n* `fields: String|Object|MissyProjection?`: Fields projection for the related entities. Optional.\n\n    With the help of this field, you can load partial related entities.\n\n* `sort: String|Object|Array|MissySort?`: Sort specification for the related entities. Optional.\n* `options: Object?`: Driver-dependent options for the related [`Model.find()`](#modelfindcriteria-fields-sort-optionsq) method. Optional.\n\nRelations are effectively loaded with a single query per relation, irrespective to the number of host entities.\n\nAfter the method is executed, all `entities` will have the `prop` property populated with the related entities:\n\n* For `hasOne`, this is a single entity, or `undefined` when no related entity exists.\n* For `hasMany`, this is always an array, possibly - empty.\n\n#### Model.saveRelated(entities, prop, options?):Q\nFor the given entities, save their related entities as defined by the `prop` relation.\n\nArguments:\n\n* `entities: Object|Array.<Object>`: Entity of the current model, or an array of them\n* `prop: String|Array.<String>|undefined`: The relation name to save, or multiple relation names as an array.\n\n    When `undefined` is given, all available relations are saved.\n\n    You can also save nested relations using the '.'-notation: `'articles.comments'` (see [Model.withRelated](#modelwithrelatedprop-model)).\n\n* `options: Object?`: Driver-dependent options for the related [`Model.save()`](#modelsaveentities-optionsq) method. Optional.\n\nThis method automatically sets the foreign keys on the related entities and saves them to the DB.\n\n#### Model.removeRelated(entities, prop, options?):Q\nFor the given entities, remove their related entities as defined by the `prop` relation.\n\nArguments:\n\n* `entities: Object|Array.<Object>`: Entity of the current model, or an array of them\n* `prop: String|Array.<String>|undefined`: (same as above)\n* `options: Object?`: Driver-dependent options for the related [`Model.removeQuery()`](#modelremovequerycriteria-optionsq) method. Optional.\n\nThis method removes all entities that are related to this one with the specified relation.\n\n#### Model.withRelated(prop, ...):Model\nAutomatically process the related entities with the next query:\n\n* - find(), findOne(): load related entities\n* - insert(), update(), save(): save related entities (replaces them & removes the missing ones)\n* - remove(): remove related entities\n\nIn fact, this method just stashes the arguments for loadRelated(), saveRelated(), removeRelated(), and calls the\ncorresponding method in the subsequent query:\n\n* `Model.withRelated(prop, fields, sort, options)` when going to load entities\n* `Model.withRelated(prop, options)` when going to save entities\n* `Model.withRelated(prop, options)` when going to remove entities\n\nSee examples below.\n\n\n\n### Example\n\nFor instance, having the following schema:\n\n```js\nvar User = schema.define('User', {\n    id: Number,\n    login: String\n});\n\nvar Article = schema.define('Article', {\n    id: Number,\n    user_id: Number,\n    title: String\n    text: String\n});\n\nvar Comment = schema.define('Comment', {\n    id: Number,\n    user_id: Number,\n    article_id: Number,\n    ctime: Date,\n    text: String,\n});\n\n// Define relations\nUser.hasMany('articles', Article, {'id': 'user_id'});\nArticle.hasMany('comments', Comment, { 'id' : 'article_id' });\n\nArticle.hasOne('author', User, {'user_id': 'id'});\nComment.hasOne('article', Article, {'article_id': 'id'});\nComment.hasOne('author', User, {'user_id': 'id'});\n```\n\n#### Saving Related Rntities\n\n```js\nUser\n    .withRelated('articles') // process the named relation in the subsequent query\n    .save([\n        {\n            login: 'dizzy',\n            articles: [\n                // When Dizzy gets an id, the related entities will use it\n                { title: 'First post', text: 'Welcome to my page' },\n                { title: 'Second post', text: 'Welcome to my page' },\n            ]\n        }\n    ])\n    .then(function(){\n        // 'dizzy' saved, with 2 posts\n    });\n```\n\n#### Loading Related Rntities\n\n```js\nUser\n    .withRelated('articles') // load articles into the `articles` field\n    .withRelated('articles.comments', {}, { ctime: -1 }) // load comments for each article, sorted (nested relation)\n    .find({ age: { $gt: 18 } })\n    .then(function(users){\n        users[0]; // user\n        users[0].articles; // her articles\n        users[0].articles[0].comments; // comments for each article\n    });\n```\n\n#### Removing Related Rntities\n\n```js\nUser\n    .withRelated('articles')\n    .remove({ id: 1 })\n    .then(function(user){\n        // User with id=1 removed, as well as her articles\n    });\n```\n\n\n\n\nRecipes\n=======\n\nValidation\n----------\n\nMissy does not support any validation out of the box, but you're free to choose any external validation engine.\n\nThe current approach is to install the validation procedure into the [`beforeExport` Model hook](#converter-hooks)\nand check entities that are saved or updated. Note that this approach won't validate entities modified with\n[Model.updateQuery](#modelupdatequerycriteria-update-optionsq), as this method does not handle full entities!\n\nAn example is on its way.\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/kolypto/nodejs-missy.git"
  },
  "scripts": {
    "test": "./node_modules/.bin/nodeunit tests/*-test.js"
  },
  "version": "0.0.2"
}
